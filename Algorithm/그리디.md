그리디의 대표적인 팀노트 - 크루스칼 구현

```python
#특정 원소가 속한 집합 찾기
def find_parent(parent, x):
 #루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
 if parent[x] != x:
   parent[x] = find_parent(parent, parent[x])
 return parent[x]

#두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
 a = find_parent(parent, a)
 b = find_parent(parent, b)
 if a < b:
   parent[b] = a
 else:
   parent[a] = b

#노드의 개수와 간선(union 연산)의 개수 입력받기
v, e = map(int, input().split())
#부모 테이블 초기화
parent = [0] * (v + 1) 

#모든 간선을 담을 리스트와 최종 비용을 담을 변수
edges = []
result = 0

#부모 테이블상에서, 무보를 자기 자신으로 초기화
for i in range(1, v+1):
 parent[i] = i

#모든 간선에 대한 정보 입력받기
for _ in range(e):
 a, b, cost = map(int, input().split())
 #비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 비용으로 설정
 edges.append((cost, a, b))

#간선을 비용순으로 정렬
edges.sort()

#간선을 하나씩 확인하며
for edge in edges:
 cost, a, b = edge
 #사이클이 발생하지 않는 경우에만 집합에 포함
 if find_parent(parent, a) != find_parent(parent, b):
   union_parent(parent, a, b)
   result += cost

print(result)

```


### 그리디

•  그리디 개념
문제를 해결하는 과정에서 그 순간 순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식

•  그리디 알고리즘이 적용 가능한 대표적 예 & 구현
1. 거스름돈 나눠주기
그리디 알고리즘의 가장 대표적인 문제로, 거스름돈 문제의 경우 '가장 큰 화폐 단위부터' 돈을 거슬러 주는 것에 초점을 맞춰 문제를 해결해 나간다.
문제예시: 현재 카운터에 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정했을 때, 손님에게 거슬러줘야 할 돈이 N원이라면, 거슬러 줘야 할 동전의 최소 개수를 구하라.

N = 1260 이라고 가정할 때의 풀이과정
↓
초기 - 남은 돈: 1,260원
점원: 500, 500, 100, 100, 50, 10
손님: (아무 것도 없는 상태)
화폐 단위
500
100
50
10
손님이 받은 개수
0
0
0
0
 
남은 돈: 260원
점원: 100, 100, 50, 10
손님: 500, 500
화폐 단위
500
100
50
10
손님이 받은 개수
2
0
0
0
 
남은 돈: 60원
점원: 50, 10
손님: 500, 500, 100, 100
화폐 단위
500
100
50
10
손님이 받은 개수
2
2
0
0
 
남은 돈: 10원
점원: 10
손님: 500, 500, 100, 100, 50
화폐 단위
500
100
50
10
손님이 받은 개수
2
2
1
0
 
남은 돈: 0원
점원: (아무 것도 없는 상태)
손님: 500, 500, 100, 100, 50, 10
화폐 단위
500
100
50
10
손님이 받은 개수
2
2
1
1
 
따라서 N = 1260 일 때 손님이 받은 동전의 최소 개수는 6개
↓
[구현 코드]
N = 1260
cnt = 0

list = [500, 100, 50, 10]

for i in list:
    cnt += N // i #해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기(몫에 해당)
    N %= i #나눈 후의 나머지 값을 다시 N 값으로 초기화시킴

print(cnt)

5585(거스름돈) : https://www.acmicpc.net/problem/5585  (브론즈)
11047(동전 0) : https://www.acmicpc.net/problem/11047  (실버)
-> 브론즈 문제는 당일에 풀어보기

2. 큰 수의 법칙
문제: 큰 수의 법칙은 다양한 수로 이루어진 배열이 주어질 때, 주어진 배열의 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 특징이 있다.
이러한 큰 수의 법칙에 따라 최종적으로 더해진 답을 출력하시오.
입력 조건: 첫째 줄에 N, M, K의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
	    둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다.
	    입력으로 주어지는 K는 항상 M보다 작거나 같다.

N = 5, M = 8, K = 3이라고 가정했을 때의 풀이 과정
↓
길이가 5인 배열이 들어오고, 총 8번을 더해서 가장 큰 수를 만들어야 함(단, 각 배열 값에 대해 최대 3번까지의 연속 덧셈 허용)

[2, 4, 5, 4, 6]

정렬을 먼저 하고, 가장 큰 수부터 더하기 시작

[2, 4, 4, 5, 6] 

6















이 과정을 K번째만큼 반복 / 각 숫자를 더할 때마다 총 더하는 횟수인 M값은 하나씩 빼줌

6
6
6











가장 큰 값인 6을 K 번째만큼 더하는 과정을 마쳤으니, 그 다음 큰 숫자인 5를 한 번 더해줌
현재의 M = 5

6
6
6
5









이 후 5를 연속 더하는 것이 아닌, 가장 큰 숫자인 6으로 돌아가 K번 만큼 더하는 것을 반복

6
6
6
5
6
6
6



위의 과정을 반복하면 최종적으로는 아래와 같음

6
6
6
5
6
6
6
5

이때, M = 0이 되면 더하는 것을 마치고, 지금까지 더한 값을 최종 출력
따라서 답은: 46
↓
[구현 코드]
n, m, k = map(int, input().split())

data = list(map(int, input().split()))

data.sort() #오름차순 정렬
first = data[n - 1]  #가장 큰 수
second = data[n - 2]  #두 번째로 큰 수

result = 0

while True:
   for i in range(k):  #가장 큰 수 k번 더하기
       if m == 0:  #m이 0이면 반복문 탈출
           break
       result += first
       m -= 1  #더할 때마다 1씩 빼기
   if m == 0:  #m이 0이면 반복문 탈출
       break
   result += second  #두 번째로 큰 수를 한 번 더하기
   m -= 1  #더할 때마다 1씩 빼기

print(result)

•  문제 풀어보기
11399(ATM) : https://www.acmicpc.net/problem/11399
1049(기타줄) : https://www.acmicpc.net/problem/1049
1946(신입사원) : https://www.acmicpc.net/problem/1946

•  문제 풀어보기(필수)
프로그래머스 탐욕법 6문제 중 앞 3문제
